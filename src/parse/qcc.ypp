%skeleton "lalr1.cc"
%require "3.8.1"
%language "c++"

%define api.value.type variant
%define api.token.raw
%define api.token.constructor
%define api.token.prefix {TOK_}

%locations
%define parse.assert
%define parse.trace
%define parse.error detailed
%define parse.lac full

%code requires {
    #include <string>
    #include <vector>
    #include "ast/ast.hpp"
    class Driver;
}

%param {Driver &drv}
%code {
    #include "parse/driver.hpp"
}

%token ASSIGN COMMA LBRACE RBRACE SEMICOLON RETURN
%left <BuiltinOperator> OP_BIT_OR
%left <BuiltinOperator> OP_BIT_XOR
%left <BuiltinOperator> OP_BIT_AND
%left <BuiltinOperator> OP_EQ OP_NE
%left <BuiltinOperator> OP_LT OP_GT OP_LE OP_GE
%left <BuiltinOperator> OP_PLUS OP_MINUS
%left <BuiltinOperator> OP_STAR OP_FSLASH
%precedence <BuiltinOperator> OP_NOT OP_BIT_NOT
%precedence PREC_NEG
%left LPAREN RPAREN

%token <BuiltinType> BUILTIN_TYPE
%token <std::string> IDENTIFIER
%token <long> INT_LITERAL
%token <char> CHAR_LITERAL

%type <FnDeclNode *> fnDecl
%type <FnDefNode *> fnDef
%type <TypeNode *> type
%type <ParamNode *> param
%type <StatementNode *> statement declaration initialization assignment return
%type <FnCallNode *> fnCall
%type <ExprNode *> expr
%type <LiteralNode *> literal

%type <std::vector<ParamNode *> *> paramList
%type <std::vector<StatementNode *> *> block blockWithBraces
%type <std::vector<ExprNode *> *> argList

%%

%start file;
file
    :
    | file fnDecl
    | file fnDef {
        drv.fnDefNodes.push_back($2);
        delete drv.cs->varTypes;
        drv.cs->varTypes = new std::unordered_map<std::string, TypeNode *>();
      }
    ;

fnDecl
    : type IDENTIFIER LPAREN RPAREN SEMICOLON {
        $$ = new FnDeclNode($1, $2);
        drv.cs->addFnDecl($$);
      }
    | type IDENTIFIER LPAREN paramList RPAREN SEMICOLON {
        $$ = new FnDeclNode($1, $2, *$4);
        drv.cs->addFnDecl($$);
        delete $4;
      }
    ;

fnDef
    : type IDENTIFIER LPAREN RPAREN blockWithBraces {
        $$ = new FnDefNode($1, $2, *$5);
        drv.cs->addFnDecl($$);
        delete $5;
      }
    | type IDENTIFIER LPAREN paramList RPAREN blockWithBraces {
        $$ = new FnDefNode($1, $2, *$4, *$6);
        drv.cs->addFnDecl($$);
        delete $4;
        delete $6;
      }
    ;

type
    : BUILTIN_TYPE { $$ = new TypeNode($1); }
    /* | IDENTIFIER { $$ = new TypeNode($1); } */
    ;

paramList
    : param { $$ = new std::vector<ParamNode *>(); $$->push_back($1); }
    | paramList COMMA param { $1->push_back($3); $$ = $1; }
    ;

param
    : type IDENTIFIER { $$ = new ParamNode($1, $2); }
    ;

blockWithBraces
    : LBRACE block RBRACE { $$ = $2; }
    ;

block
    : { $$ = new std::vector<StatementNode *>(); }
    | block statement SEMICOLON { $1->push_back($2); $$ = $1; }
    ;

statement
    : declaration { $$ = $1; }
    | initialization { $$ = $1; }
    | assignment { $$ = $1; }
    | return { $$ = $1; }
    | fnCall { $$ = new StatementNode($1); }
    ;

declaration
    : type IDENTIFIER { $$ = new StatementNode($1, $2); drv.cs->setVarType($2, $1); }
    ;

initialization
    : type IDENTIFIER ASSIGN expr { $$ = new StatementNode($1, $2, $4); drv.cs->setVarType($2, $1); }
    ;

assignment
    : IDENTIFIER ASSIGN expr { $$ = new StatementNode($1, $3); }
    ;

return
    : RETURN expr { $$ = new StatementNode($2); }
    ;

fnCall
    : IDENTIFIER LPAREN argList RPAREN { $$ = new FnCallNode($1, drv.cs->getFnDecl($1), *$3); delete $3; }
    | IDENTIFIER LPAREN RPAREN { $$ = new FnCallNode($1, drv.cs->getFnDecl($1)); }
    ;

argList
    : expr { $$ = new std::vector<ExprNode *>(); $$->push_back($1); }
    | argList COMMA expr { $1->push_back($3); $$ = $1; }
    ;

expr
    : literal { $$ = new ExprNode($1); }
    | IDENTIFIER { $$ = new ExprNode($1, drv.cs->getVarType($1)); }
    | fnCall { $$ = new ExprNode($1); }
    | expr OP_PLUS    expr { $$ = new ExprNode($2, $1, $3); }
    | expr OP_MINUS   expr { $$ = new ExprNode($2, $1, $3); }
    | expr OP_STAR    expr { $$ = new ExprNode($2, $1, $3); }
    | expr OP_FSLASH  expr { $$ = new ExprNode($2, $1, $3); }
    | expr OP_EQ      expr { $$ = new ExprNode($2, $1, $3); }
    | expr OP_NE      expr { $$ = new ExprNode($2, $1, $3); }
    | expr OP_LT      expr { $$ = new ExprNode($2, $1, $3); }
    | expr OP_GT      expr { $$ = new ExprNode($2, $1, $3); }
    | expr OP_LE      expr { $$ = new ExprNode($2, $1, $3); }
    | expr OP_GE      expr { $$ = new ExprNode($2, $1, $3); }
    | OP_MINUS        expr { $$ = new ExprNode($1, $2); } %prec PREC_NEG
    | OP_NOT          expr { $$ = new ExprNode($1, $2); }
    | OP_BIT_NOT      expr { $$ = new ExprNode($1, $2); }
    | expr OP_BIT_AND expr { $$ = new ExprNode($2, $1, $3); }
    | expr OP_BIT_OR  expr { $$ = new ExprNode($2, $1, $3); }
    | expr OP_BIT_XOR expr { $$ = new ExprNode($2, $1, $3); }
    | LPAREN expr RPAREN { $$ = $2; }
    ;

literal
    : INT_LITERAL { $$ = new LiteralNode($1); }
    | CHAR_LITERAL { $$ = new LiteralNode($1); }
    ;

%%

void yy::parser::error(const location_type &l, const std::string &str) {
    std::cerr << l << ": " << str << '\n';
    drv.res = 1;
}
