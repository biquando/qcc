%skeleton "lalr1.cc"
%require "3.8.1"
%language "c++"

%define api.value.type variant
%define api.token.constructor

%code requires {
    #include <string>
    #include <vector>
    #include "ast.hpp"
    class Driver;
}

%param {Driver &drv}
%code {
    #include "parse/driver.hpp"
}

%left <BuiltinOperator> OP_EQ OP_NE
%left <BuiltinOperator> OP_LT OP_GT OP_LE OP_GE
%left <BuiltinOperator> OP_PLUS OP_MINUS
%left <BuiltinOperator> OP_STAR OP_FSLASH
%precedence <BuiltinOperator> OP_NOT
%precedence PREC_NEG
%left '(' ')'

%token <BuiltinType> BUILTIN_TYPE
%token <std::string> IDENTIFIER
%token <int> INT_LITERAL
%token <char> CHAR_LITERAL

%type <FnDefNode *> fnDef
%type <TypeNode *> type
%type <ParamNode *> param
%type <StatementNode *> statement declaration initialization assignment
%type <FnCallNode *> fnCall
%type <ExprNode *> expr
%type <LiteralNode *> literal

%type <std::vector<ParamNode *> *> paramList
%type <std::vector<StatementNode *> *> block blockWithBraces
%type <std::vector<ExprNode *> *> argList

%%

file
    :
    | file fnDef { drv.fnDefNodes.push_back($2); }
    ;

fnDef
    : type IDENTIFIER '(' ')' blockWithBraces {
        $$ = new FnDefNode($1, $2, *$5);
        delete $5;
      }
    | type IDENTIFIER '(' paramList ')' blockWithBraces {
        $$ = new FnDefNode($1, $2, *$4, *$6);
        delete $4;
        delete $6;
      }
    ;

type
    : BUILTIN_TYPE { $$ = new TypeNode($1); }
    | IDENTIFIER { $$ = new TypeNode($1); }
    ;

paramList
    : param { $$ = new std::vector<ParamNode *>(); $$->push_back($1); }
    | paramList ',' param { $1->insert($1->begin(), $3); $$ = $1; }
    ;

param
    : type IDENTIFIER { $$ = new ParamNode($1, $2); }
    ;

blockWithBraces
    : '{' block '}' { $$ = $2; }
    ;

block
    : { $$ = new std::vector<StatementNode *>(); }
    | block statement ';' { $1->push_back($2); $$ = $1; }
    ;

statement
    : declaration { $$ = $1; }
    | initialization { $$ = $1; }
    | assignment { $$ = $1; }
    | fnCall { $$ = new StatementNode($1); }
    ;

declaration
    : type IDENTIFIER { $$ = new StatementNode($1, $2); }
    ;

initialization
    : type IDENTIFIER '=' expr { $$ = new StatementNode($1, $2, $4); }
    ;

assignment
    : expr '=' expr { $$ = new StatementNode($1, $3); }
    ;

fnCall
    : expr '(' argList ')' { $$ = new FnCallNode($1, *$3); delete $3; }
    | expr '(' ')' { $$ = new FnCallNode($1); }
    ;

argList
    : expr { $$ = new std::vector<ExprNode *>(); $$->push_back($1); }
    | argList ',' expr { $1->insert($1->begin(), $3); $$ = $1; }
    ;

/* expr
    : literal { $$ = new ExprNode($1); }
    | IDENTIFIER { $$ = new ExprNode($1); }
    | fnCall { $$ = new ExprNode($1); }
    | expr binaryOp expr { $$ = new ExprNode($2, $1, $3); }
    | unaryOp expr { $$ = new ExprNode($1, $2); }
    | '(' expr ')' { $$ = $2; }
    ; */
expr
    : literal { $$ = new ExprNode($1); }
    | IDENTIFIER { $$ = new ExprNode($1); }
    | fnCall { $$ = new ExprNode($1); }
    | expr OP_PLUS   expr { $$ = new ExprNode($2, $1, $3); }
    | expr OP_MINUS  expr { $$ = new ExprNode($2, $1, $3); }
    | expr OP_STAR   expr { $$ = new ExprNode($2, $1, $3); }
    | expr OP_FSLASH expr { $$ = new ExprNode($2, $1, $3); }
    | expr OP_EQ     expr { $$ = new ExprNode($2, $1, $3); }
    | expr OP_NE     expr { $$ = new ExprNode($2, $1, $3); }
    | expr OP_LT     expr { $$ = new ExprNode($2, $1, $3); }
    | expr OP_GT     expr { $$ = new ExprNode($2, $1, $3); }
    | expr OP_LE     expr { $$ = new ExprNode($2, $1, $3); }
    | expr OP_GE     expr { $$ = new ExprNode($2, $1, $3); }
    | OP_MINUS       expr { $$ = new ExprNode($1, $2); } %prec PREC_NEG
    | OP_NOT         expr { $$ = new ExprNode($1, $2); }
    | '(' expr ')' { $$ = $2; }
    ;

literal
    : INT_LITERAL { $$ = new LiteralNode($1); }
    | CHAR_LITERAL { $$ = new LiteralNode($1); }
    ;

%%

void yy::parser::error(const std::string &str) {
    std::cerr << "Parser error: " << str << std::endl;
}
