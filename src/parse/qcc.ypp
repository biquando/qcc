%skeleton "lalr1.cc"
%require "3.8.1"
%language "c++"

%define api.value.type variant
%define api.token.constructor

%code requires {
    #include <string>
    #include <vector>
    #include "ast.hpp"
    class Driver;
}

%param {Driver &drv}
%code {
    #include "parse/driver.hpp"
}

%token <BuiltinType> BUILTIN_TYPE
%token <BuiltinOperator> BINARY_OP
%token <BuiltinOperator> UNARY_OP
%token <std::string> IDENTIFIER
%token <int> INT_LITERAL
%token <char> CHAR_LITERAL

%type <FnDefNode *> fnDef
%type <TypeNode *> type
%type <ParamNode *> param
%type <StatementNode *> statement declaration initialization assignment
%type <FnCallNode *> fnCall
%type <ExprNode *> expr
%type <LiteralNode *> literal

%type <std::vector<ParamNode *> *> paramList
%type <std::vector<StatementNode *> *> block blockWithBraces
%type <std::vector<ExprNode *> *> argList

%%

file    :
        | file fnDef { drv.fnDefNodes.push_back($2); }
        ;

fnDef   : type IDENTIFIER '(' ')' blockWithBraces {
                $$ = new FnDefNode($1, $2, *$5);
                delete $5;
          }
        | type IDENTIFIER '(' paramList ')' blockWithBraces {
                $$ = new FnDefNode($1, $2, *$4, *$6);
                delete $4;
                delete $6;
          }
        ;

type    : BUILTIN_TYPE { $$ = new TypeNode($1); }
        | IDENTIFIER { $$ = new TypeNode($1); }
        ;

paramList   : param { $$ = new std::vector<ParamNode *>();
                      $$->push_back($1); }
            | paramList ',' param { $1->insert($1->begin(), $3); $$ = $1; }
            ;

param   : type IDENTIFIER { $$ = new ParamNode($1, $2); }
        ;

blockWithBraces : '{' block '}' { $$ = $2; }
                ;

block   : { $$ = new std::vector<StatementNode *>(); }
        | block statement ';' { $1->push_back($2); $$ = $1; }
        ;

statement   : declaration { $$ = $1; }
            | initialization { $$ = $1; }
            | assignment { $$ = $1; }
            | fnCall { $$ = new StatementNode($1); }
            ;

declaration : type IDENTIFIER { $$ = new StatementNode($1, $2); }
            ;

initialization  : type IDENTIFIER '=' expr { $$ = new StatementNode($1, $2, $4); }
                ;

assignment  : expr '=' expr { $$ = new StatementNode($1, $3); }
            ;

fnCall  : expr '(' argList ')' { $$ = new FnCallNode($1, *$3); delete $3; }
        | expr '(' ')' { $$ = new FnCallNode($1); }
        ;

argList : expr { $$ = new std::vector<ExprNode *>();
                 $$->push_back($1); }
        | argList ',' expr { $1->insert($1->begin(), $3); $$ = $1; }
        ;

expr    : literal { $$ = new ExprNode($1); }
        | IDENTIFIER { $$ = new ExprNode($1); }
        | fnCall { $$ = new ExprNode($1); }
        | expr BINARY_OP expr { $$ = new ExprNode($2, $1, $3); }
        | UNARY_OP expr { $$ = new ExprNode($1, $2); }
        | '(' expr ')' { $$ = $2; }
        ;

literal : INT_LITERAL { $$ = new LiteralNode(LiteralType::Int, $1); }
        | CHAR_LITERAL { $$ = new LiteralNode(LiteralType::Char, $1); }
        ;

%%

void yy::parser::error(const std::string &str) {
    std::cerr << "Parser error: " << str << std::endl;
}
