%skeleton "lalr1.cc"
%require "3.8.1"
%language "c++"

%define api.value.type variant
%define api.token.raw
%define api.token.constructor
%define api.token.prefix {TOK_}

%locations
%define parse.assert
%define parse.trace
%define parse.error detailed
%define parse.lac full

%code requires {
    #include <string>
    #include <vector>
    #include "ast/ast.hpp"
    class Driver;
}

%param {Driver &drv}
%code {
    #include "parse/driver.hpp"
}

%token ASSIGN COMMA LBRACE RBRACE SEMICOLON
%left <BuiltinOperator> OP_EQ OP_NE
%left <BuiltinOperator> OP_LT OP_GT OP_LE OP_GE
%left <BuiltinOperator> OP_PLUS OP_MINUS
%left <BuiltinOperator> OP_STAR OP_FSLASH
%precedence <BuiltinOperator> OP_NOT
%precedence PREC_NEG
%left LPAREN RPAREN

%token <BuiltinType> BUILTIN_TYPE
%token <std::string> IDENTIFIER
%token <int> INT_LITERAL
%token <char> CHAR_LITERAL

%type <FnDefNode *> fnDef
%type <TypeNode *> type
%type <ParamNode *> param
%type <StatementNode *> statement declaration initialization assignment
%type <FnCallNode *> fnCall
%type <ExprNode *> expr
%type <LiteralNode *> literal

%type <std::vector<ParamNode *> *> paramList
%type <std::vector<StatementNode *> *> block blockWithBraces
%type <std::vector<ExprNode *> *> argList

%%

%start file;
file
    :
    | file fnDef { drv.fnDefNodes.push_back($2); }
    ;

fnDef
    : type IDENTIFIER LPAREN RPAREN blockWithBraces {
        $$ = new FnDefNode($1, $2, *$5);
        delete $5;
      }
    | type IDENTIFIER LPAREN paramList RPAREN blockWithBraces {
        $$ = new FnDefNode($1, $2, *$4, *$6);
        delete $4;
        delete $6;
      }
    ;

type
    : BUILTIN_TYPE { $$ = new TypeNode($1); }
    | IDENTIFIER { $$ = new TypeNode($1); }
    ;

paramList
    : param { $$ = new std::vector<ParamNode *>(); $$->push_back($1); }
    | paramList COMMA param { $1->push_back($3); $$ = $1; }
    ;

param
    : type IDENTIFIER { $$ = new ParamNode($1, $2); }
    ;

blockWithBraces
    : LBRACE block RBRACE { $$ = $2; }
    ;

block
    : { $$ = new std::vector<StatementNode *>(); }
    | block statement SEMICOLON { $1->push_back($2); $$ = $1; }
    ;

statement
    : declaration { $$ = $1; }
    | initialization { $$ = $1; }
    | assignment { $$ = $1; }
    | fnCall { $$ = new StatementNode($1); }
    ;

declaration
    : type IDENTIFIER { $$ = new StatementNode($1, $2); }
    ;

initialization
    : type IDENTIFIER ASSIGN expr { $$ = new StatementNode($1, $2, $4); }
    ;

assignment
    : IDENTIFIER ASSIGN expr { $$ = new StatementNode($1, $3); }
    ;

fnCall
    : IDENTIFIER LPAREN argList RPAREN { $$ = new FnCallNode($1, *$3); delete $3; }
    | IDENTIFIER LPAREN RPAREN { $$ = new FnCallNode($1); }
    ;

argList
    : expr { $$ = new std::vector<ExprNode *>(); $$->push_back($1); }
    | argList COMMA expr { $1->push_back($3); $$ = $1; }
    ;

expr
    : literal { $$ = new ExprNode($1); }
    | IDENTIFIER { $$ = new ExprNode($1); }
    | fnCall { $$ = new ExprNode($1); }
    | expr OP_PLUS   expr { $$ = new ExprNode($2, $1, $3); }
    | expr OP_MINUS  expr { $$ = new ExprNode($2, $1, $3); }
    | expr OP_STAR   expr { $$ = new ExprNode($2, $1, $3); }
    | expr OP_FSLASH expr { $$ = new ExprNode($2, $1, $3); }
    | expr OP_EQ     expr { $$ = new ExprNode($2, $1, $3); }
    | expr OP_NE     expr { $$ = new ExprNode($2, $1, $3); }
    | expr OP_LT     expr { $$ = new ExprNode($2, $1, $3); }
    | expr OP_GT     expr { $$ = new ExprNode($2, $1, $3); }
    | expr OP_LE     expr { $$ = new ExprNode($2, $1, $3); }
    | expr OP_GE     expr { $$ = new ExprNode($2, $1, $3); }
    | OP_MINUS       expr { $$ = new ExprNode($1, $2); } %prec PREC_NEG
    | OP_NOT         expr { $$ = new ExprNode($1, $2); }
    | LPAREN expr RPAREN { $$ = $2; }
    ;

literal
    : INT_LITERAL { $$ = new LiteralNode($1); }
    | CHAR_LITERAL { $$ = new LiteralNode($1); }
    ;

%%

void yy::parser::error(const location_type &l, const std::string &str) {
    std::cerr << l << ": " << str << '\n';
    drv.res = 1;
}
